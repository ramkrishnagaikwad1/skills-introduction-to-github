package com.example.jasper56;

import net.sf.jasperreports.engine.*; import net.sf.jasperreports.engine.export.JRGraphics2DExporter; import net.sf.jasperreports.engine.export.JRPdfExporter; import net.sf.jasperreports.engine.export.JRGraphics2DExporterParameter; import net.sf.jasperreports.engine.export.JRPdfExporterParameter; import net.sf.jasperreports.engine.JRExporterParameter;

import org.apache.pdfbox.io.MemoryUsageSetting; import org.apache.pdfbox.multipdf.PDFMergerUtility; import org.apache.pdfbox.pdmodel.PDDocument; import org.apache.pdfbox.pdmodel.PDPage; import org.apache.pdfbox.pdmodel.common.PDRectangle; import org.apache.pdfbox.pdmodel.graphics.image.PDImageXObject;

import javax.imageio.IIOImage; import javax.imageio.ImageIO; import javax.imageio.ImageWriteParam; import javax.imageio.ImageWriter; import javax.imageio.stream.MemoryCacheImageOutputStream; import java.awt.; import java.awt.image.BufferedImage; import java.io.; import java.nio.file.Files; import java.nio.file.Paths; import java.util.; import java.util.List; import java.util.concurrent.;

/**

Final ready-to-run single-file solution for JasperReports 5.6.

Uses Jasper56Compat wrapper to isolate deprecated setParameter calls.


Exports English pages as vector PDF and renders the rest as images -> JPEG -> PDF.


Merges PDFs, enforces 5s overall timeout and tries to keep output <= 5 MB.


Adjust DPI/QUALITY_STEPS/TIMEOUT_SECONDS/MAX_BYTES as needed. */ public class Jasper56SplitterMerger {

private static final int INITIAL_DPI = 300; private static final int MIN_DPI = 90; private static final long MAX_BYTES = 5L * 1024L * 1024L; // 5 MB private static final int TIMEOUT_SECONDS = 5; private static final float[] QUALITY_STEPS = new float[]{0.9f, 0.8f, 0.6f, 0.45f, 0.3f};

/**

Main API method.

@param jasperPrint        filled JasperPrint

@param englishStartIndex  inclusive 0-based

@param englishEndIndex    inclusive 0-based

@return merged PDF bytes (throws if can't satisfy constraints) */ public static byte[] exportSplitMerge(final JasperPrint jasperPrint, final int englishStartIndex, final int englishEndIndex) throws Exception {

Callable<byte[]> task = () -> { int total = jasperPrint.getPages().size(); if (englishStartIndex < 0 || englishEndIndex < englishStartIndex || englishEndIndex >= total) { throw new IllegalArgumentException("Invalid english page indexes"); }

// copy english pages
 JasperPrint englishJP = copyPages(jasperPrint, englishStartIndex, englishEndIndex);

 // export english vector pdf
 byte[] englishPdf = Jasper56Compat.exportPdfToBytes(englishJP);

 // collect hindi pages
 List<Integer> hindiPages = new ArrayList<>();
 for (int i = 0; i < total; i++) {
     if (i < englishStartIndex || i > englishEndIndex) hindiPages.add(i);
 }

 byte[] hindiPdf;
 if (hindiPages.isEmpty()) {
     hindiPdf = createEmptyPdf();
 } else {
     hindiPdf = buildPdfFromRenderedPagesWithTarget(jasperPrint, hindiPages, INITIAL_DPI, MAX_BYTES);
 }

 byte[] merged = mergePdfBytes(Arrays.asList(englishPdf, hindiPdf));
 if (merged.length > MAX_BYTES) {
     throw new IOException("Merged PDF exceeds limit: " + merged.length + " bytes");
 }
 return merged;

};

ExecutorService ex = Executors.newSingleThreadExecutor(); Future<byte[]> f = ex.submit(task); try { return f.get(TIMEOUT_SECONDS, TimeUnit.SECONDS); } catch (TimeoutException te) { f.cancel(true); throw new TimeoutException("Operation timed out after " + TIMEOUT_SECONDS + " seconds"); } finally { ex.shutdownNow(); } }


// ---------------- helpers ----------------

private static JasperPrint copyPages(JasperPrint src, int startInclusive, int endInclusive) { JasperPrint copy = new JasperPrint(); copy.setName(src.getName()); copy.setPageWidth(src.getPageWidth()); copy.setPageHeight(src.getPageHeight()); copy.setOrientation(src.getOrientationValue()); if (src.getPropertiesMap() != null) copy.setPropertyMap(new HashMap<>(src.getPropertiesMap()));

@SuppressWarnings("unchecked")
 List<JRPrintPage> pages = src.getPages();
 @SuppressWarnings("unchecked")
 List<JRPrintPage> destPages = copy.getPages();
 for (int i = startInclusive; i <= endInclusive; i++) {
     destPages.add(pages.get(i));
 }
 return copy;

}

private static byte[] createEmptyPdf() throws IOException { try (PDDocument doc = new PDDocument(); ByteArrayOutputStream baos = new ByteArrayOutputStream()) { doc.save(baos); return baos.toByteArray(); } }

private static byte[] mergePdfBytes(List<byte[]> pdfs) throws IOException { PDFMergerUtility merger = new PDFMergerUtility(); ByteArrayOutputStream out = new ByteArrayOutputStream(); for (byte[] p : pdfs) merger.addSource(new ByteArrayInputStream(p)); merger.setDestinationStream(out); merger.mergeDocuments(MemoryUsageSetting.setupMainMemoryOnly()); return out.toByteArray(); }

private static byte[] buildPdfFromRenderedPagesWithTarget(JasperPrint source, List<Integer> pageIndexes, int initialDpi, long maxBytes) throws Exception { int dpi = initialDpi;

while (dpi >= MIN_DPI) {
     List<BufferedImage> images = new ArrayList<>(pageIndexes.size());
     for (int p : pageIndexes) {
         BufferedImage img = Jasper56Compat.renderPageToImage(source, p, dpi);
         images.add(img);
     }

     for (float q : QUALITY_STEPS) {
         byte[] pdf = createPdfFromImages(images, dpi, q);
         if (pdf.length <= maxBytes) return pdf;
     }
     dpi -= 60;
 }

 // final attempt
 List<BufferedImage> images = new ArrayList<>();
 for (int p : pageIndexes) images.add(Jasper56Compat.renderPageToImage(source, p, Math.max(MIN_DPI, 72)));

 byte[] finalPdf = createPdfFromImages(images, Math.max(MIN_DPI, 72), QUALITY_STEPS[QUALITY_STEPS.length - 1]);
 if (finalPdf.length > maxBytes) {
     throw new IOException("Unable to meet size target. Final size: " + finalPdf.length);
 }
 return finalPdf;

}

private static byte[] createPdfFromImages(List<BufferedImage> images, int dpi, float quality) throws IOException { try (PDDocument doc = new PDDocument(); ByteArrayOutputStream baos = new ByteArrayOutputStream()) { for (BufferedImage bi : images) { float widthPts = bi.getWidth() * 72f / dpi; float heightPts = bi.getHeight() * 72f / dpi; PDPage page = new PDPage(new PDRectangle(widthPts, heightPts)); doc.addPage(page);

byte[] jpg = bufferedImageToJpegBytes(bi, quality);
         PDImageXObject pdImg = PDImageXObject.createFromByteArray(doc, jpg, "img");
         try (org.apache.pdfbox.pdmodel.PDPageContentStream cs =
                      new org.apache.pdfbox.pdmodel.PDPageContentStream(doc, page)) {
             cs.drawImage(pdImg, 0, 0, widthPts, heightPts);
         }
     }
     doc.save(baos);
     return baos.toByteArray();
 }

}

private static byte[] bufferedImageToJpegBytes(BufferedImage image, float quality) throws IOException { ByteArrayOutputStream baos = new ByteArrayOutputStream(); Iterator<ImageWriter> writers = ImageIO.getImageWritersByFormatName("jpeg"); if (!writers.hasNext()) { ImageIO.write(image, "png", baos); return baos.toByteArray(); } ImageWriter writer = writers.next(); ImageWriteParam param = writer.getDefaultWriteParam(); if (param.canWriteCompressed()) { param.setCompressionMode(ImageWriteParam.MODE_EXPLICIT); param.setCompressionQuality(Math.max(0.01f, Math.min(1f, quality))); } try (MemoryCacheImageOutputStream mcios = new MemoryCacheImageOutputStream(baos)) { writer.setOutput(mcios); IIOImage iio = new IIOImage(image, null, null); writer.write(null, iio, param); mcios.flush(); writer.dispose(); } return baos.toByteArray(); }

// ---------------- Example main (demo) ---------------- // NOTE: Replace jasperPrint loading with your app's logic. This main is for quick testing.

public static void main(String[] args) throws Exception { // Example: load a .jasper file and fill it (this code is illustrative and may need adapting) if (args.length < 4) { System.out.println("Usage: java -jar app.jar <compiledReport.jasper> <datasourceClass> <englishStart> <englishEnd>"); return; }

String jasperFile = args[0];
 String dsClass = args[1];
 int englishStart = Integer.parseInt(args[2]);
 int englishEnd = Integer.parseInt(args[3]);

 // Load compiled .jasper (you probably fill it programmatically in your app)
 JasperReport report = (JasperReport) JRLoader.loadObjectFromFile(jasperFile);
 // For demo we use empty datasource. Replace with your data & parameters.
 JasperPrint jasperPrint = JasperFillManager.fillReport(report, new HashMap<>(), new JREmptyDataSource());

 byte[] out = exportSplitMerge(jasperPrint, englishStart, englishEnd);
 Files.write(Paths.get("final_merged.pdf"), out);
 System.out.println("Written final_merged.pdf (size=" + out.length + " bytes)");

} }


// ------------------ Jasper56Compat (wrapper to isolate deprecated calls) ------------------

final class Jasper56Compat {

private Jasper56Compat() { }

@SuppressWarnings("deprecation")
public static byte[] exportPdfToBytes(JasperPrint jp) throws JRException {
    ByteArrayOutputStream baos = new ByteArrayOutputStream();
    JRPdfExporter exporter = new JRPdfExporter();
    exporter.setParameter(JRExporterParameter.JASPER_PRINT, jp);
    exporter.setParameter(JRExporterParameter.OUTPUT_STREAM, baos);
    exporter.setParameter(JRPdfExporterParameter.IS_COMPRESSED, Boolean.TRUE);
    exporter.exportReport();
    return baos.toByteArray();
}

@SuppressWarnings("deprecation")
public static BufferedImage renderPageToImage(JasperPrint jasperPrint, int pageIndex, int dpi) throws JRException {
    int pageWidthPoints = jasperPrint.getPageWidth();
    int pageHeightPoints = jasperPrint.getPageHeight();

    int imgW = Math.max(1, Math.round(pageWidthPoints * dpi / 72f));
    int imgH = Math.max(1, Math.round(pageHeightPoints * dpi / 72f));

    BufferedImage image = new BufferedImage(imgW, imgH, BufferedImage.TYPE_INT_RGB);
    Graphics2D g2d = image.createGraphics();
    try {
        g2d.setPaint(Color.WHITE);
        g2d.fillRect(0, 0, imgW, imgH);

        double scale = dpi / 72d;
        g2d.scale(scale, scale);

        JRGraphics2DExporter exporter = new JRGraphics2DExporter();
        exporter.setParameter(JRExporterParameter.JASPER_PRINT, jasperPrint);
        exporter.setParameter(JRGraphics2DExporterParameter.GRAPHICS_2D, g2d);
        exporter.setParameter(JRGraphics2DExporterParameter.PAGE_INDEX, pageIndex);
        exporter.exportReport();
    } finally {
        g2d.dispose();
    }
    return image;
}

}

