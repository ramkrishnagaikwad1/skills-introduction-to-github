import net.sf.jasperreports.engine.JasperPrint;
import net.sf.jasperreports.engine.JasperPrintManager;
import org.apache.pdfbox.pdmodel.PDDocument;
import org.apache.pdfbox.pdmodel.PDPage;
import org.apache.pdfbox.pdmodel.common.PDRectangle;
import org.apache.pdfbox.pdmodel.graphics.image.JPEGFactory;
import org.apache.pdfbox.pdmodel.PDPageContentStream;

import java.awt.*;
import java.awt.image.BufferedImage;
import java.io.ByteArrayOutputStream;

/**
 * Safe JasperPrint -> compressed-image-PDF converter that prevents "Dimensions too large".
 */
public class JasperToSafeCompressedPdf {

    // Tweak these constants to tune quality / size / safety
    private static final int MAX_PIXELS = 10000;  // max allowed pixel width or height (safe for PDFBox)
    private static final float DEFAULT_DPI = 100f; // starting DPI to try (balanced)
    private static final float MIN_DPI = 30f; // never go below this DPI (avoid unreadable)
    private static final float JPEG_QUALITY = 0.65f; // 0.0 - 1.0 (0.65 is a good default)

    public static byte[] convert(JasperPrint jasperPrint) throws Exception {
        if (jasperPrint == null) throw new IllegalArgumentException("jasperPrint must not be null");

        try (PDDocument doc = new PDDocument(); ByteArrayOutputStream baos = new ByteArrayOutputStream()) {

            int pages = jasperPrint.getPages().size();
            for (int i = 0; i < pages; i++) {
                // Obtain page width/height in points (Jasper uses points; 72 points = 1 inch)
                // Note: getPageWidth/getPageHeight return units used by Jasper (commonly points)
                double pageWidthPts = jasperPrint.getPageWidth();   // e.g., ~595 for A4
                double pageHeightPts = jasperPrint.getPageHeight(); // e.g., ~842 for A4

                // Compute the maximum DPI that keeps both dimensions <= MAX_PIXELS
                // pixels = (points * dpi) / 72
                double dpiForMaxWidth  = (MAX_PIXELS * 72.0) / pageWidthPts;
                double dpiForMaxHeight = (MAX_PIXELS * 72.0) / pageHeightPts;

                // choose DPI = min(defaultDpi, dpiForMaxWidth, dpiForMaxHeight)
                float dpi = (float) Math.min(DEFAULT_DPI, Math.min(dpiForMaxWidth, dpiForMaxHeight));

                // Ensure DPI not below MIN_DPI; if it is, set to MIN_DPI (we'll still cap pixel dims later)
                if (dpi < MIN_DPI) dpi = MIN_DPI;

                // Render the page to image at computed safe dpi
                BufferedImage pageImage = JasperPrintManager.printPageToImage(jasperPrint, i, dpi);

                // As a final safety: if image still exceeds MAX_PIXELS due to rounding/odd units, downscale it
                pageImage = capMaxDimension(pageImage, MAX_PIXELS, MAX_PIXELS);

                // Compute PDF page size in points from image pixels and used dpi:
                // widthPts = (pixels * 72) / dpi
                float widthPt  = (float) ((pageImage.getWidth()  * 72.0) / dpi);
                float heightPt = (float) ((pageImage.getHeight() * 72.0) / dpi);

                // If widthPt/heightPt are zero or invalid, fallback to standard A4 in points
                if (widthPt <= 0 || heightPt <= 0) {
                    widthPt  = PDRectangle.A4.getWidth();
                    heightPt = PDRectangle.A4.getHeight();
                }

                PDPage page = new PDPage(new PDRectangle(widthPt, heightPt));
                doc.addPage(page);

                // Create a compressed JPEG PDImageXObject
                org.apache.pdfbox.pdmodel.graphics.image.PDImageXObject pdImage =
                        JPEGFactory.createFromImage(doc, pageImage, JPEG_QUALITY);

                // Draw image to PDF page (covering full page)
                try (PDPageContentStream cs = new PDPageContentStream(doc, page)) {
                    cs.drawImage(pdImage, 0, 0, widthPt, heightPt);
                }

                // release resources
                pageImage.flush();
            }

            doc.save(baos);
            return baos.toByteArray();
        }
    }

    // Rescales the image if it exceeds the max dimensions, preserving aspect ratio.
    private static BufferedImage capMaxDimension(BufferedImage src, int maxW, int maxH) {
        int w = src.getWidth();
        int h = src.getHeight();
        if (w <= maxW && h <= maxH) return src;

        double scale = Math.min((double) maxW / w, (double) maxH / h);
        int newW = Math.max(1, (int) (w * scale));
        int newH = Math.max(1, (int) (h * scale));

        BufferedImage resized = new BufferedImage(newW, newH, BufferedImage.TYPE_INT_RGB);
        Graphics2D g = resized.createGraphics();
        g.setRenderingHint(RenderingHints.KEY_INTERPOLATION, RenderingHints.VALUE_INTERPOLATION_BILINEAR);
        g.setBackground(Color.WHITE);
        g.clearRect(0, 0, newW, newH);
        g.drawImage(src, 0, 0, newW, newH, null);
        g.dispose();
        return resized;
    }
}
